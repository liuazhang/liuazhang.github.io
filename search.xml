<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1.6.1）常见的计算机网络体系结构</title>
    <url>/2020/05/07/1-6-1%EF%BC%89%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="常见的计算机网络体系结构"><a href="#常见的计算机网络体系结构" class="headerlink" title="常见的计算机网络体系结构"></a>常见的计算机网络体系结构</h2><h3 id="1-1-OSI体系结构"><a href="#1-1-OSI体系结构" class="headerlink" title="1.1 OSI体系结构"></a>1.1 OSI体系结构</h3><p>​    7，应用层</p>
<a id="more"></a>

<p>​    6，表示层 </p>
<p>​    5，会话层</p>
<p>​    4，运输层</p>
<p>​    3，网络层</p>
<p>​    2，数据链路层</p>
<p>​    1，物理层</p>
<h3 id="1-2-TCP-IP体系结构"><a href="#1-2-TCP-IP体系结构" class="headerlink" title="1.2 TCP/IP体系结构"></a>1.2 TCP/IP体系结构</h3><p>​    4，应用层 【HTTP SMTP】 【DNS RTP】</p>
<p>​    3，运输层  TCP（可靠传输） UDP（不可靠传输）</p>
<p>​    2，网际层    IP</p>
<p>​    1，网络接口层  网络接口 </p>
<p>​    （路由器只包含网际层、网络接口层）</p>
<h3 id="1-3原理体系结构"><a href="#1-3原理体系结构" class="headerlink" title="1.3原理体系结构"></a>1.3原理体系结构</h3><p>​    5，应用层</p>
<p>​    4，运输层</p>
<p>​    3，网络层   </p>
<p>​    2，数据链路层    </p>
<p>​    1，物理层   </p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>概述</tag>
      </tags>
  </entry>
  <entry>
    <title>1.6.3）计算机网络体系结构分层思想举例</title>
    <url>/2020/05/07/1-6-3%EF%BC%89%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%88%86%E5%B1%82%E6%80%9D%E6%83%B3%E4%B8%BE%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="计算机网络体系结构分层思想举例"><a href="#计算机网络体系结构分层思想举例" class="headerlink" title="计算机网络体系结构分层思想举例"></a>计算机网络体系结构分层思想举例</h2><p>应用层 ——》 HTTP报文</p>
<p>运输层 ——》 HTTP TCP （添加TCP首部</p>
<a id="more"></a>

<p>网络层 ——》 HTTP TCP IP （添加IP首部</p>
<p>数据链路层 ——》 ETH HTTP TCP IP ETH （添加首部和尾部，使之成为帧</p>
<p>物理层 ——》 将帧看作比特流，并添加前导码</p>
<p>物理层将添加有前导码的比特流变换成相应的信号发送到传输媒体，信号通过传输媒体到达路由器</p>
<p><img src="/2020/05/07/1-6-3%EF%BC%89%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%88%86%E5%B1%82%E6%80%9D%E6%83%B3%E4%B8%BE%E4%BE%8B/1.6.3.png" alt="分层思想"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>概述</tag>
      </tags>
  </entry>
  <entry>
    <title>1.6.2）计算机网络体系结构分层的必要性</title>
    <url>/2020/05/07/1-6-2%EF%BC%89%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%88%86%E5%B1%82%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7/</url>
    <content><![CDATA[<h2 id="计算机网络体系结构分层的必要性"><a href="#计算机网络体系结构分层的必要性" class="headerlink" title="计算机网络体系结构分层的必要性"></a>计算机网络体系结构分层的必要性</h2><h3 id="实现计算机网络所要解决的各种主要问题："><a href="#实现计算机网络所要解决的各种主要问题：" class="headerlink" title="实现计算机网络所要解决的各种主要问题："></a>实现计算机网络所要解决的各种主要问题：</h3><p><strong>原理体系结构</strong></p>
<p><strong>5、应用层</strong> :</p>
<ul>
<li><p>通过应用进程间的交互来完成特定的网络应用</p>
 <a id="more"></a>

<p>（支持万维网应用的HTTP协议</p>
<p>​    支持电子邮件的SMTP协议</p>
<p>​    支持文件传输的FTP协议 ，，，）</p>
</li>
</ul>
<p><strong>4、运输层</strong>（进程之间基于网络的通信）:</p>
<ul>
<li><p>如何解决进程之间基于网络的通信问题</p>
</li>
<li><p>出现传输错误时如何处理 ，，，</p>
</li>
</ul>
<p><strong>3、网络层</strong>（分组在多个网络间（路由）进行传输）:</p>
<ul>
<li><p>如何标识各网络以及网络中各主机（网络和主机共同编址的问题，例如IP地址）</p>
</li>
<li><p>路由器如何转发分组，如何进行路由选择 ，，，</p>
</li>
</ul>
<p><strong>2、数据链路层</strong>（分组在一个网络上传输）:</p>
<ul>
<li><p>如何表示网络中的各主机（主机编址问题，例如MAC地址）</p>
</li>
<li><p>如何从信号所表示的一连串比特流中区分出地址和数据</p>
</li>
<li><p>如何协调各主机征用总线 ，，，</p>
</li>
</ul>
<p><strong>1、物理层</strong> : </p>
<ul>
<li><p>采用怎样的传输媒体（介质）</p>
</li>
<li><p>采用怎样的物理接口</p>
</li>
<li><p>使用怎样的信号表示比特0和1 ，，，</p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>概述</tag>
      </tags>
  </entry>
  <entry>
    <title>1.6.4）计算机网络体系结构中的专用术语</title>
    <url>/2020/05/07/1-6-4%EF%BC%89%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E4%B8%93%E7%94%A8%E6%9C%AF%E8%AF%AD/</url>
    <content><![CDATA[<h2 id="计算机网络体系结构中的专用术语"><a href="#计算机网络体系结构中的专用术语" class="headerlink" title="计算机网络体系结构中的专用术语"></a>计算机网络体系结构中的专用术语</h2><ul>
<li><p><strong>实体</strong> ： 任何可发送或接收信息的硬件或软件进程。</p>
</li>
<li><p><strong>对等实体</strong>： 收发双方相同层次中的实体。</p>
<a id="more"></a>
</li>
<li><p><strong>协议</strong> ： 控制两个对等实体进行逻辑通信的规则的集合。</p>
</li>
<li><p><strong>协议的三要素</strong> ： 语法 语义 同步</p>
<ul>
<li><p><strong>语法</strong> 定义所交换信息的格式</p>
</li>
<li><p><strong>语义</strong> 定义收发双方所要完成的操作</p>
</li>
<li><p><strong>同步</strong> 定义收发双方的时序关系</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>服务</strong></li>
</ul>
<ul>
<li><p>在协议的控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务。</p>
</li>
<li><p>要实现本层协议，还需要使用下面一层所提供的服务。</p>
</li>
<li><p>协议是“水平的”，服务是“垂直的”。</p>
</li>
<li><p>实体看得见相邻下层所提供的服务，并不知道实现该服务的具体协议。也就是说下面的协议对上面的实体是“透明”的。</p>
</li>
</ul>
<ul>
<li><p><strong>服务访问点</strong> ： 在同一系统中相邻两层的实体交换信息的逻辑接口，用于区分不同的服务类型。</p>
<ul>
<li><p>数据链路层的服务访问点为帧的“类型”字段。</p>
</li>
<li><p>网络层的服务访问点为IP数据报首部中的“协议字段”。</p>
</li>
<li><p>运输层的服务访问点为“端口号”。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>服务原语</strong> ： 上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令称为服务原语。</li>
</ul>
<ul>
<li><p><strong>协议数据单元PDU</strong> ： 对等层次之间传送的数据包称为该层的协议数据单元。</p>
<ul>
<li><p>应用层： 报文（message）</p>
</li>
<li><p>运输层： TCP报文段（segment）或UDP用户数据报（datagram）</p>
</li>
<li><p>网络层： IP数据报或分组（packet）</p>
</li>
<li><p>链路层： 帧（frame）</p>
</li>
<li><p>物理层： 比特流（bit stream）</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>服务数据单元SDU</strong> ： 同一系统内，层与层之间交换的数据包成为服务数据单元。<ul>
<li>多个SDU可以合成为一个PDU；一个SDU也可划分为几个PDU。</li>
</ul>
</li>
</ul>
<p><img src="/2020/05/07/1-6-4%EF%BC%89%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E4%B8%93%E7%94%A8%E6%9C%AF%E8%AF%AD/1.6.4.png" alt="。。。"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>概述</tag>
      </tags>
  </entry>
  <entry>
    <title>2.4）编码与调制</title>
    <url>/2020/05/07/2-4%EF%BC%89%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6/</url>
    <content><![CDATA[<h2 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h2><p><strong>编码</strong></p>
<p><img src="/2020/05/07/2-4%EF%BC%89%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6/2.4.1.png" alt="。。。"></p>
<p><strong>消息</strong></p>
<ul>
<li><p><strong>数据</strong>，运送消息的实体</p>
</li>
<li><p><strong>信号</strong>，数据的电磁表现</p>
<a id="more"></a>
</li>
<li><p><strong>基带信号</strong>，基带发出的原始电信号</p>
</li>
<li><p><strong>数字基带信号</strong>， –编码–》数字信道  以太网（曼彻斯特编码，4B/5B，8B/10B</p>
<p>————————-调制–》模拟信道   WiFi （CCK/DSSS/OFDM调制</p>
</li>
<li><p><strong>模拟基带信号</strong>， –编码–》数字信道  对音频信号进行编码的脉码调制PCM</p>
<p>————————-调制–》模拟信道  语音数据加载到模拟的载波信号中传输。</p>
<p>​                                                              频分复用FDM技术，充分利用带宽资源》。</p>
</li>
<li><p><strong>码元</strong>，在使用时间域的波形表示数字型号时，代表不同离散数值的基本波形。</p>
</li>
</ul>
<p><strong>常用编码</strong></p>
<ul>
<li><p><strong>不归零编码</strong>（存在同步问题）</p>
</li>
<li><p><strong>归零编码</strong>，每个码元传输结束后信号都要“归零”，所以接受双方只要在信号归零后进行采样即可，不需要单独的时钟信号。</p>
<p><em>但是，归零编码中大部分的数据带宽，都用来传输“归零”而浪费掉了。</em></p>
</li>
<li><p><strong>曼彻斯特编码</strong></p>
</li>
<li><p><strong>差分曼彻斯特编码</strong></p>
</li>
</ul>
<p><img src="/2020/05/07/2-4%EF%BC%89%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6/2.4.2.png" alt="。。。"></p>
<p><strong>调制</strong></p>
<p>基本调制，调幅（AM）、调频（FM）、调相（PM）</p>
<p>使用基本调制方法，一个码元只能包含一个比特信息</p>
<p><strong>混合调频</strong></p>
<p> 因为频率和相位是相关的，即频率是相位随时间的变化率。所以一次只能调制频率和相位两个中的一个。</p>
<p> 通常情况下，相位和振幅可以结合起来一起调制，称为正交振幅调制QAM。</p>
<p><strong>QAM-16</strong></p>
<ul>
<li><p>12种相位 （码元和圆心的连线与横坐标的夹角可看作是相位</p>
</li>
<li><p>每种相位有1或2种振幅可选 （码元与圆心连线的距离可看作是振幅</p>
</li>
<li><p>可以调制出16种码元（波形），每种码元可以对应表示4个比特</p>
</li>
<li><p>码元与4个比特的对应关系采用格雷码（任意两个相邻码元只有一个比特不同</p>
</li>
</ul>
<p><img src="/2020/05/07/2-4%EF%BC%89%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6/2.4.3.png" alt="。。。"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>物理层</tag>
      </tags>
  </entry>
  <entry>
    <title>2.5）信道极限容量</title>
    <url>/2020/05/07/2-5%EF%BC%89%E4%BF%A1%E9%81%93%E7%9A%84%E6%9E%81%E9%99%90%E5%AE%B9%E9%87%8F/</url>
    <content><![CDATA[<h2 id="信道极限容量"><a href="#信道极限容量" class="headerlink" title="信道极限容量"></a>信道极限容量</h2><p><strong>1、造成信号失真的因素</strong>：</p>
<ul>
<li><p>码元传输速率</p>
</li>
<li><p>信号传输距离</p>
</li>
<li><p>噪声干扰</p>
<a id="more"></a>
</li>
<li><p>传输媒体质量</p>
</li>
</ul>
<p><strong>2、码元传输速率</strong>又叫波特率、调制速率、波形速率或符号速率。</p>
<p><strong>3、当1个码元只携带1比特信息时，波特率（码元/秒）与比特率（比特/秒）在数值上是相等的。</strong></p>
<p><strong>4、当1个码元携带n比特信息量时，则波特率转化成比特率时，数值要乘以n。</strong></p>
<p><strong>5、</strong><img src="/2020/05/07/2-5%EF%BC%89%E4%BF%A1%E9%81%93%E7%9A%84%E6%9E%81%E9%99%90%E5%AE%B9%E9%87%8F/2.5.1.png" alt="。。。"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;c是信道的极限传输速率，单位为b/s；</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;W为信道带宽，单位为Hz；</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;s是信道内所传输信号的平均功率；</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;N是信道内的高斯噪声功率；</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;S/N是信噪比，使用分贝（dB）作为度量单位</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;信噪比（dB）=<img src="/2020/05/07/2-5%EF%BC%89%E4%BF%A1%E9%81%93%E7%9A%84%E6%9E%81%E9%99%90%E5%AE%B9%E9%87%8F/2.5.2.png" alt="。。。">（dB）</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>物理层</tag>
      </tags>
  </entry>
  <entry>
    <title>3.1）数据链路层概述</title>
    <url>/2020/05/07/3-1%EF%BC%89%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="数据链路层概述"><a href="#数据链路层概述" class="headerlink" title="数据链路层概述"></a>数据链路层概述</h2><ul>
<li><p><strong>链路</strong>（Link）就是从一个结点到相邻结点的一段物理线路，而中间没有任何其他的交换结点。</p>
</li>
<li><p><strong>数据链路</strong>（Data Link）是指把实现通信协议的硬件和软件加到链路上，就构成了数据链路。</p>
</li>
<li><p>数据链路以<strong>帧</strong>为单位传输和处理数据。</p>
<a id="more"></a>

</li>
</ul>
<h3 id="使用点对点信道的数据链路层"><a href="#使用点对点信道的数据链路层" class="headerlink" title="使用点对点信道的数据链路层"></a>使用点对点信道的数据链路层</h3><ul>
<li><p><strong>三个重要问题</strong></p>
<ul>
<li><p>封装成帧</p>
</li>
<li><p>差错检测</p>
</li>
<li><p>可靠传输</p>
</li>
</ul>
</li>
</ul>
<h3 id="使用广播信道的数据链路层"><a href="#使用广播信道的数据链路层" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h3><ul>
<li><p>共享式以太网的媒体接入控制协议CSMA/CD</p>
</li>
<li><p>802.11局域网的媒体接入控制协议CSMA/CA</p>
</li>
</ul>
<h3 id="数据链路层的互联设备"><a href="#数据链路层的互联设备" class="headerlink" title="数据链路层的互联设备"></a>数据链路层的互联设备</h3><ul>
<li>网桥，交换机的工作原理</li>
<li>集线器（物理层互联设备）与交换机的区别</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>数据链路层</tag>
      </tags>
  </entry>
  <entry>
    <title>3.2）封装成帧</title>
    <url>/2020/05/08/3-2%EF%BC%89%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7/</url>
    <content><![CDATA[<h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><ul>
<li><p><strong>封装成帧</strong>是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧。</p>
<ul>
<li><p>帧头和帧尾中包含有重要的控制信息。</p>
</li>
<li><p>帧头和帧尾的作用之一就是帧定界。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>透明传输</strong>是指<strong>数据链路层对上层交付的传输数据没有任何限制</strong>，就好像数据链路层不存在一样。</p>
<a id="more"></a>

<ul>
<li>面向字节的物理链路使用字节填充（或称字符填充）的方法实现透明传输。</li>
<li>面向比特的物理链路使用比特填充的方法实现透明传输。  </li>
</ul>
<p><br><img src="/2020/05/08/3-2%EF%BC%89%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7/1.jpg" alt="..."></p>
</li>
<li><p>为了提高帧的传输效率，应当使帧的数据部分的长度尽可能大些。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>数据链路层</tag>
      </tags>
  </entry>
  <entry>
    <title>3.4）可靠传输</title>
    <url>/2020/05/09/3-4%EF%BC%89%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/</url>
    <content><![CDATA[<h2 id="1、可靠传输的基本概念"><a href="#1、可靠传输的基本概念" class="headerlink" title="1、可靠传输的基本概念"></a>1、可靠传输的基本概念</h2><p>&emsp;使用<strong>差错检测技术</strong>（例如循环冗余校验CRC），接收方的数据链路层就可检测出帧在传输过程中是否产生了<strong>误码</strong>（比特错误）。   </p>
<p>&emsp;数据链路层向上层提供的服务类型</p>
<p>&emsp;&emsp;<strong>不可靠传输服务</strong>：<strong>仅仅丢弃有误码的帧</strong>，其他什么也不做；</p>
<p>&emsp;&emsp;<strong>可靠传输服务</strong>：想办法实现<strong>发送端发送什么，接收端就收到什么</strong></p>
<p>&emsp;一般情况下，<strong>有线链路</strong>的误码率较低，为了减小开销，<strong>并不要求数据链路层</strong>向上提供<strong>可靠</strong>传输服务。即使出现了误码，可靠传输的问题由其上层处理。</p>
<p>&emsp;<strong>无线链路</strong>易受干扰，误码率较高，因此<strong>要求数据链路层</strong>必须向上层提供<strong>可靠</strong>传输服务。</p>
<p>&emsp;<strong>比特差错</strong>只是传输差错的一种。</p>
<a id="more"></a>

<p>&emsp;整个计算机网络体系结构来看，传输差错还包含<strong>分组丢失</strong>，<strong>分组失序</strong>以及<strong>分组重复</strong>。</p>
<p>&emsp;分组丢失，分组失序以及分组重复这些传输差错，一般不会出现在数据链路层，而会出现在其上层。</p>
<p>&emsp;<strong>可靠传输服务并不仅局限于数据链路层</strong>，其他各层均可实现可靠传输。</p>
<p>&emsp;可靠传输的实现比较复杂，开销也比较大，是否使用可靠传输取决于应用需求。</p>
<br>

<hr>
<hr>
<br>

<h2 id="2、可靠传输的实现机制"><a href="#2、可靠传输的实现机制" class="headerlink" title="2、可靠传输的实现机制"></a>2、可靠传输的实现机制</h2><p>三种实现机制：停止-等待协议、回退N帧协议、选择重传协议。</p>
<p><strong>这三种可靠传输实现机制的基本原理并不仅限于数据链路层，可以应用到计算机网络体系结构的各层协议中。</strong></p>
<br>

<h3 id="2-1、停止-等待协议SW（Stop-and-Wait）"><a href="#2-1、停止-等待协议SW（Stop-and-Wait）" class="headerlink" title="2.1、停止-等待协议SW（Stop-and-Wait）"></a>2.1、停止-等待协议SW（Stop-and-Wait）</h3><blockquote>
<p>发送方发送数据data</p>
<p>接收方若没有发现误码，接受该数据分组，并回复ACK（确认分组</p>
<p>发送方发送下一个数据</p>
</blockquote>
<blockquote>
<p>发送方发送数据data</p>
<p>接收方若发现误码，丢弃该数据分组，并回复NAK（否认分组</p>
<p>重新发送data</p>
</blockquote>
<p>所以<strong>发送方每发送一个数据分组后，并不会将该数据分组立刻删除，只有收到针对该数据分组的确认分组后，才能将其从缓存中删除</strong></p>
<p>//<strong><em>超时计时器<em>，若发送方长时间得不到接收方响应，则重传原来的数据分组，这就叫做</em>超时重传。</em></strong></p>
<p>//<strong>如果接受方所回应的AC丢失，则会触发<em>超时重传</em>，这时就会发生<em>分组重复</em>为了避免这种情况，可以给每个分组带上序号，通过序号，接收方可以识别分组是否重复，若发现重复，接收方丢弃重复分组，并回应ACK，（ 因为只要保证此次与上次分组不同，所以用一比特来编号就可以了。</strong></p>
<p>//<strong>若ACK迟到，则会产生重复确认，同理也要为确认分组进行编号</strong></p>
<blockquote>
<blockquote>
<p>接收端检测到数据分组有误时,将其丢弃并等待发送方的超时重传。但对于误码率较高的点对点链路，为使发</p>
<p>送方<strong>尽早重传，</strong>也可<strong>给发送方发送NAK分组。</strong></p>
</blockquote>
<blockquote>
<p>为了让接收方能够判断所收到的数据分组是否是重复的，需要给<strong>数据分组编号。</strong>由于停止-等待协议的停等特性，<strong>只需1个比特</strong>就够了，即编号0和1。</p>
</blockquote>
<blockquote>
<p>为了让发送方能够判断所收到的ACK是否是重复的，需要给<strong>ACK分组编号，</strong>所用比特数量<strong>与分组编号所用数量一样。</strong>数据链路层一般不会出现ACK分组迟到的情况，因此在<strong>数据链路层实现停止-等待协议可以不用给ACK分组编号。</strong></p>
</blockquote>
<blockquote>
<p>超时计时器设置的<strong>重传时间</strong>应仔细选择。一般可将重传时间选为<strong>略大于“从发送方到接收方的平均往返时间”。</strong></p>
<blockquote>
<p>数据链路层点对点的往返时间比较确定，重传时间比较好设定。</p>
</blockquote>
<blockquote>
<p>然而在运输层，由于端到端往返时间非常不确定，设置合适的重传时间有时并不容易。</p>
</blockquote>
</blockquote>
</blockquote>
<br>

<h4 id="停止-等待协议的信道利用率"><a href="#停止-等待协议的信道利用率" class="headerlink" title="停止-等待协议的信道利用率"></a><u>停止-等待协议的信道利用率</u></h4><p><img src="/2020/05/09/3-4%EF%BC%89%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/1.jpg" alt="。。。"></p>
<p><strong>TD：发送方发送数据分组所消耗的发送时延。</strong></p>
<p><strong>RTT：收发双方之间的往返时间。</strong></p>
<p><strong>TA：接收方发送确认分组所消耗的发送时延。</strong></p>
<p><strong>TA一般都远小于TD，可以忽略。</strong></p>
<p><strong>&emsp;当往返时延RTT远大于数据帧发送时延TD时（例如使用卫星链路），信道利用率非常低。</strong></p>
<p>&emsp;若出现重传，则对于传送有用的数据信息来说，信道利用率还要降低。</p>
<p>&emsp;为了克服停止-等待协议信道利用率很低的缺点，就产生了另外两种协议，即后退N帧协议GBN和选择重传协议SR</p>
<p><img src="/2020/05/09/3-4%EF%BC%89%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/2.jpg" alt="。。。"></p>
<br>

<h3 id="2-2、回退N帧协议GBN（Go-Back-N）"><a href="#2-2、回退N帧协议GBN（Go-Back-N）" class="headerlink" title="2.2、回退N帧协议GBN（Go-Back-N）"></a>2.2、回退N帧协议GBN（Go-Back-N）</h3><blockquote>
<p>回退N帧协议在流水线传输的基础上利用发送窗口来限制发送方连续发送数据分组的数量，是一种ARQ协议；</p>
<p>在协议的工作过程中发送窗口和接收窗口不断向前滑动，因此这类协议又称为滑动窗口协议；</p>
<p>由于回退N帧协议的特性，当通信线路质量不好时，其信道利用率并不比停止-等待协议高；</p>
</blockquote>
<h4 id="发送方："><a href="#发送方：" class="headerlink" title="发送方："></a><u>发送方：</u></h4><p>&emsp;发送窗口尺寸WT的取值范围是<em>1 &lt; WT &lt;= 2^n-1</em>其中，n是构成分组序号的比特数量。</p>
<p>&emsp;&emsp;<em>WT = 1</em>   ——》停止等待协议；</p>
<p>&emsp;&emsp;<em>WT &gt;= 2^n-1</em>  ——》接收方无法分辨新，旧数据分组；</p>
<p>&emsp;发送方可在未收到接收方确认分组的情况下，将序号落在发送窗口内的多个数据分组全部发送出去。</p>
<p>&emsp;发送方只有收到对已发送的数据分组的确认时，发送窗口才能向前相应滑动。</p>
<p>&emsp;发送方收到多个重复确认时，可在重传计时器超时前尽早开始重传，由具体实现决定。</p>
<p>&emsp;发送方发送窗口内某个已发送的数据分组产生超时重发时，其后续在发送窗口内且已发送的数据分组也必须全部重传，这就是回退N帧协议名称的由来。</p>
<h4 id="接收方："><a href="#接收方：" class="headerlink" title="接收方："></a><u>接收方：</u></h4><p>&emsp;接收方的接收窗口尺寸WR的取值范围是<em>WR = 1</em>因此接收方只能按序接收数据分组。</p>
<p>&emsp;接收方只接收序号落在接收窗口内且无误码的数据分组，并且将接收窗口向前滑动一个位置，与此同时给发送方发回相应的确认分组。为了减少开销，接收方不一定每收到一个按序到达且无误码的数据分组就给发送方发回一个确认分组，</p>
<p>&emsp;&emsp;而是可以在连续收到好几个按序到达且无误码的数据分组后（由具体实现决定），才针对最后一个数据分组发送确认分组，这称为累积确认；</p>
<p>&emsp;&emsp;或者可以在自己有数据分组要发送时才对之前按序接受且无误码的数据分组进行捎带确认；</p>
<p>&emsp;接收方收到未按序到达的数据分组，除丢弃外，还要对最近按序接收的数据分组进行确认；</p>
<h4 id="例题："><a href="#例题：" class="headerlink" title="例题："></a><u><strong>例题：</strong></u></h4><p><img src="/2020/05/09/3-4%EF%BC%89%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/3.jpg" alt="。。。"></p>
<br>

<h3 id="2-3、选择重传协议"><a href="#2-3、选择重传协议" class="headerlink" title="2.3、选择重传协议"></a>2.3、选择重传协议</h3><h4 id="发送方：-1"><a href="#发送方：-1" class="headerlink" title="发送方："></a><u>发送方：</u></h4><p>&emsp;发送窗口尺寸WT的取值范围是<em>1 &lt; WT &lt;= 2^(n-1</em>)其中，n是构成分组序号的比特数量。</p>
<p>&emsp;&emsp;<em>WT = 1</em>   ——》停止等待协议；</p>
<p>&emsp;&emsp;<em>WT &gt;= 2^(n-1)</em>  ——》接收方无法分辨新，旧数据分组；</p>
<p>&emsp;发送方可在未收到接收方确认分组的情况下，将序号落在发送窗口内的多个数据分组全部发送出去。</p>
<p>&emsp;发送方只有按序收到对已发送的数据分组的确认时，发送窗口才能向前相应滑动；若收到未按序到达的确认分组时，对其进行记录，以防止其相应数据分组的超时重发，但发送窗口不能向前滑动。</p>
<h4 id="接收方：-1"><a href="#接收方：-1" class="headerlink" title="接收方："></a><u>接收方：</u></h4><p>&emsp;接收方的接收窗口尺寸WR的取值范围是<em>1&lt; WR &lt;= WT</em>因此接收方只能按序接收数据分组。</p>
<p>&emsp;<em>WR = 1</em> ——》回退N帧协议</p>
<p>&emsp;<em>WR = WT</em> ——》无意义</p>
<p>&emsp;接收方可接收未按序到达但没有误码并且序号落在接收窗口内的数据分组；</p>
<p>&emsp;为了使发送方仅重传出现差错的分组，接收方不能在采用累计确认，而需要对每个正确接收到的数据分组进行逐一确认；</p>
<p>&emsp;接收方只有在按序接收数据分组后，接收窗口才能向前滑动。</p>
<h4 id="例题：-1"><a href="#例题：-1" class="headerlink" title="例题："></a><u>例题</u>：</h4><p><img src="/2020/05/09/3-4%EF%BC%89%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/4.jpg" alt="。。。"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>数据链路层</tag>
      </tags>
  </entry>
  <entry>
    <title>3.3）差错检测</title>
    <url>/2020/05/08/3-3%EF%BC%89%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<h2 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h2><p>1、实际的通信链路都不是理想的，比特在传输过程中可能会产生差错：1可能会变成0，而0可能会变成1.这称为<strong>比特差错</strong></p>
<p>2、在一段时间内，传输错误的比特占所传输比特总数的比特率称为<strong>误码率BER</strong>（Bit Error Rate）。</p>
<p>3、使用<strong>差错检测码</strong>来检测数据在传输过程中是否产生了比特差错，使数据链路层所要解决的重要问题之一。</p>
<br>

<h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><a id="more"></a>

<blockquote>
<p>&emsp;在代发送的数据后面<strong>添加1位奇偶校验位</strong>，使整个数据（包括所添加的校验位在内）中<strong>“1”的个数</strong>为奇数（奇校验）或偶数（偶校验）。</p>
</blockquote>
<p><strong>1位误码可以检测出错误，无法应对2位误码</strong></p>
<br>

<h3 id="循环冗余校验CRC（Cyclic-Redundancy-Check）"><a href="#循环冗余校验CRC（Cyclic-Redundancy-Check）" class="headerlink" title="循环冗余校验CRC（Cyclic Redundancy Check）"></a>循环冗余校验CRC（Cyclic Redundancy Check）</h3><blockquote>
<p>&emsp;收发双方约定好一个<strong>生成多项式</strong>G（x）；</p>
<p>&emsp;发送方基于待发送的数据和生成多项式计算出差错检测码（<strong>冗余码</strong>），将其添加到待传输数据的后面一起传输；</p>
<p>&emsp;接收方通过生成多项式来计算收到的数据是否产生了误码；</p>
</blockquote>
<br>

<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="/2020/05/08/3-3%EF%BC%89%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B/1.jpg" alt="..."></p>
<hr>
<p><img src="/2020/05/08/3-3%EF%BC%89%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B/2.jpg" alt="..."></p>
<br>

<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><blockquote>
<p>1、<strong>检错码</strong>只能检测出帧在传输过程中出现了差错，但并不能定位错误，因此<strong>无法纠正错误</strong>。</p>
<p>2、要想纠正传输中的差错，可以使用冗余信息更多的<strong>纠错码</strong>进行<strong>前向纠错</strong>。但纠错码的开销较大，在<strong>计算机网络中较少使用</strong>。</p>
<p>3、循环冗余校验<strong>CRC</strong>有很好的检错能力（<strong>漏检率非常低</strong>），虽然计算比较复杂，但非常<strong>易于用硬件实施</strong>，因此被<strong>广泛用于数据链路层</strong>。</p>
<p>4、在计算机网络中通常采用<strong>检错重传方式来纠正传输中的差错</strong>，<strong>或者仅仅是丢弃检测到差错的帧</strong>，这取决于数据链路层向其上层提供的是可靠传输服务还是不可靠传输服务。</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>数据链路层</tag>
      </tags>
  </entry>
  <entry>
    <title>3.5）点对点协议PPP</title>
    <url>/2020/05/13/3-5%EF%BC%89%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP/</url>
    <content><![CDATA[<h2 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h2><p><strong>PPP协议的标准文档[RFC1661,RFC1662]。</strong></p>
<p><strong>PPP协议为在点对点链路传输各种协议数据报提供了一个标准方法，主要由以下三部分构成：</strong></p>
<p>1、对各种协议数据报的封装方法（ 封装成帧）</p>
<p>2、链路控制协议LCP （ 用于建立，配置以及测试数据链路的连接        <a id="more"></a></p>
<p>3、一套网络控制协议NCPs （ 其中的每一个协议支持不同的网络层协议</p>
<br>

<p><strong>PPP帧的透明传输</strong></p>
<p>1、面向字节的异步链路使用字节填充法（插入转义字符</p>
<p>2、面向比特的同步链路使用比特填充法（零比特填充</p>
<br>

<p><strong>PPP协议的工作状态</strong></p>
<p><img src="/2020/05/13/3-5%EF%BC%89%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP/1.jpg" alt="..."></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>数据链路层</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo发布博客并部署到远端</title>
    <url>/2020/04/21/hexo%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0%E8%BF%9C%E7%AB%AF/</url>
    <content><![CDATA[<h2 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h2><p>到博客根目录下打开git</p>
<p>1、清除缓存</p>
<blockquote>
<p><strong>hexo clean</strong>  </p>
</blockquote>
<p>2、新建博客</p>
<blockquote>
<p><strong>hexo new post_name</strong> </p>
</blockquote>
<p>  在<code>source/_posts</code>中会生成文章<code>post_name.md</code></p>
<a id="more"></a>

<p>3、编写</p>
<p>​    .md文件使用的是markdown，建议使用编译器 <a href="https://typora.io/" target="_blank" rel="noopener">Typora</a> ，对于markdown的学习 <a href="https://www.runoob.com/markdown/md-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a></p>
<p>4、保存之后</p>
<blockquote>
<p><strong>hexo g</strong></p>
<p><strong>hexo s</strong></p>
</blockquote>
<h2 id="部署到远端"><a href="#部署到远端" class="headerlink" title="部署到远端"></a>部署到远端</h2><p>1、配置Git的用户信息：</p>
<blockquote>
<p><strong>git config –global user.name “GitHub用户名”</strong></p>
<p><strong>git config –global user.email “GitHub邮箱”</strong></p>
</blockquote>
<p>2、生成ssh密钥文件</p>
<blockquote>
<p><strong>ssh-keygen -t rsa -C “Github邮箱”</strong></p>
</blockquote>
<p>密钥文件会自动保存到 <code>C:\Users\Administrator\.ssh</code> </p>
<p>前往github创建个人仓库，仓库名字必须为：<strong>username.github.io</strong></p>
<p>将刚新生成的公钥id_rsa.pub添加到Github中，完了以后使用命令<strong>ssh <a href="mailto:git@github.com">git@github.com</a></strong>测试</p>
<p><img src="/2020/04/21/hexo%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0%E8%BF%9C%E7%AB%AF/1.png" alt="位置"></p>
<p>3、准备部署</p>
<p> 在正式部署之前，需要安装hexo的部署插件：</p>
<blockquote>
<p><strong>cnpm install hexo-deployer-git –save</strong></p>
</blockquote>
<p> 修改配置文件_config.yml，在deploy下指定仓库路径和部署的协议，具体配置如下：</p>
<blockquote>
<p><strong>deploy:</strong></p>
<p> <strong>repository: 刚才创建的github仓库的git地址</strong></p>
<p> <strong>type: git</strong></p>
<p> <strong>branch: master</strong></p>
</blockquote>
<blockquote>
<p>重新编译：<strong>hexo g</strong></p>
<p>然后部署：<strong>hexo d</strong></p>
</blockquote>
<p>成功后就可以登录github的项目路径查看到该网站</p>
<p><strong><a href="https://github用户名.github.io" target="_blank" rel="noopener">https://github用户名.github.io</a></strong></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>3.6）媒体接入与随机接入</title>
    <url>/2020/05/13/3-6%EF%BC%89%E5%AA%92%E4%BD%93%E6%8E%A5%E5%85%A5%E4%B8%8E%E9%9A%8F%E6%9C%BA%E6%8E%A5%E5%85%A5/</url>
    <content><![CDATA[<h2 id="3-6-1-媒体介入控制的基本概念"><a href="#3-6-1-媒体介入控制的基本概念" class="headerlink" title="3.6.1 媒体介入控制的基本概念"></a>3.6.1 媒体介入控制的基本概念</h2><p> <strong>共享信道要着重考虑的一个问题就是如何协调多个发送和接收站点对一个共享传输媒体的占用，即<em>媒体接入控制MAC</em>（Medium Access Control).</strong></p>
<ul>
<li><p><strong><a href="#静态">静态信道划分</a></strong></p>
<p>2、链路控制协议LCP （ 用于建立，配置以及测试数据链路的连接        <a id="more"></a></p>
</li>
<li><p>动态接入控制</p>
<ul>
<li><p>受控接入</p>
<ul>
<li><p>集中控制 ：<em>（有一个主站以循环方式轮询每个站点有无数据发送，只有被轮询的站点才能发送数据。最大的缺点是存在单点故障问题。</em></p>
</li>
<li><p>分散控制：<em>（各站点是平等的，并连接成一个环形网络。令牌（一个特殊的控制帧）沿环逐站传递，接收到令牌的站点才有权发送数据</em></p>
</li>
</ul>
</li>
<li><p><strong><a href="#随机">随机接入</a></strong>：<em>(所有站点通过竞争，随机地在信道上发送数据。如果恰巧有两个或更多的站点在同一时刻发送数据，测信号在共享媒体上就要产生碰撞（即发生了冲突）。使得这些站点都发送失败。因此这类协议要解决的关键问题是如何尽量避免冲突及在发生冲突后如何尽快恢复通信。著名的共享式以太网采用的就是随机接入</em></p>
</li>
</ul>
</li>
</ul>
<p><strong><em>随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已完全取代了共享式局域网，但由于无线信道的广播天性，无线局域网无线局域网仍然使用的是共享媒体技术。</em></strong></p>
<h2 id="3-6-2-静态媒体接入控制——静态信道划分"><a href="#3-6-2-静态媒体接入控制——静态信道划分" class="headerlink" title="3.6.2 静态媒体接入控制——静态信道划分"></a><span id="静态">3.6.2 静态媒体接入控制——静态信道划分</span></h2><h3 id="信道复用"><a href="#信道复用" class="headerlink" title="信道复用"></a>信道复用</h3><p><strong>复用是通信技术中的一个重要概念。复用就是通过一条物理线路同时传输多路用户的信号。</strong></p>
<p><strong>信道复用分为：</strong>频分复用FDM，时分复用TDM，波分复用WDM，码分复用CDM。</p>
<ul>
<li>FDM：频分复用的所用用户同时占用不同的频带资源并行通信。</li>
<li>TDM：时分复用的所有用户在不同的时间占用同样的频带宽度。</li>
<li>WDM：波分复用其实就是光的频分复用。</li>
<li>CDM：码分复用CDM是另一种共享信道的方法。实际上，由于该技术主要用于多址接入，人们更常用的名词是码分多址CDMA。</li>
<li>同理频分复用FDM和时分复用TDM同样可用于多址接入，相应的名词是频分多址FDMA和时分多址TDMA。</li>
</ul>
<h3 id="CDMA"><a href="#CDMA" class="headerlink" title="CDMA"></a>CDMA</h3><ul>
<li>在CMDA中，每一个比特时间再划分为m个短的间隔，称为码片（Chip），通常m的值是64或128，为了简单起见，在后续的举例中，我们假设m为8；</li>
<li>使用CDMA的每一个站被指派一个唯一的m bit码片序列。<ul>
<li>一个站如果要发送比特1，则他发送自己的m bit码片序列；</li>
<li>一个站如果要发送比特0，则发送他自己的m bit码片序列的二进制反码；</li>
</ul>
</li>
<li>码片序列的挑选原则如下：<ol>
<li>分配给每个站的码片序列必须各不相同，实际常采用伪随机码序列。</li>
<li>分配给每个站的码片序列必须相互正交（规格化内积为0）。<ul>
<li>令向量S表示站S的码片序列，令向量T表示其他任何站的码片序列。</li>
<li>两个不同站S和T的码片序列正交，就是向量S和T的规格化内积为0：</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><img src="/2020/05/13/3-6%EF%BC%89%E5%AA%92%E4%BD%93%E6%8E%A5%E5%85%A5%E4%B8%8E%E9%9A%8F%E6%9C%BA%E6%8E%A5%E5%85%A5/1.jpg" alt="..."></p>
<br>

<h2 id="3-6-3随机接入"><a href="#3-6-3随机接入" class="headerlink" title="3.6.3随机接入"></a>3.6.3<span id="随机">随机接入</span></h2><h3 id="CSMA-CA协议"><a href="#CSMA-CA协议" class="headerlink" title="CSMA/CA协议"></a>CSMA/CA协议</h3>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>数据链路层</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传</title>
    <url>/2020/05/13/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式语法</title>
    <url>/2020/05/16/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h2><h3 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h3><p>字母、数字、汉字、下划线等等，<strong>匹配与之相同的字符。</strong></p>
<a id="more"></a>

<h3 id="简单的转义字符"><a href="#简单的转义字符" class="headerlink" title="简单的转义字符"></a>简单的转义字符</h3><table>
<thead>
<tr>
<th align="center">字符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\n</td>
<td align="center">代表换行符</td>
</tr>
<tr>
<td align="center">\t</td>
<td align="center">制表符</td>
</tr>
<tr>
<td align="center">\\</td>
<td align="center">代表\本身</td>
</tr>
<tr>
<td align="center">\^, \$, \., \(, \), \{, \}, \?, \+, \*, \</td>
<td align="center">, \[, \]</td>
</tr>
</tbody></table>
<h3 id="标准字符集合："><a href="#标准字符集合：" class="headerlink" title="标准字符集合："></a>标准字符集合：</h3><ul>
<li>能够与’多种字符‘匹配的表达式</li>
<li><label style="color:red">注意区分大小写，大写是相反的意思</label></li>
</ul>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\d</td>
<td align="center">任意数字，0~9中的任意一个</td>
</tr>
<tr>
<td align="center">\w</td>
<td align="center">字母或数字或下划线，也就是A<del>Z，a</del>z，0~9，_中任意一个</td>
</tr>
<tr>
<td align="center">\s</td>
<td align="center">包括空格，制表符，换行符等空白字符的其中任意一个</td>
</tr>
<tr>
<td align="center">.</td>
<td align="center">小数点可以匹配任意一个字符（除了换行符\n）如果要匹配包括”\n“在内的所有字符，一般用[\s\S]</td>
</tr>
</tbody></table>
<h3 id="自定义字符集合"><a href="#自定义字符集合" class="headerlink" title="自定义字符集合"></a>自定义字符集合</h3><ul>
<li>[]方括号匹配方式，能够匹配方括号中<strong>任意一个</strong>字符</li>
<li><label style="color:red">方括号内 ^ 是取反的意思</label></li>
</ul>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[ab5@]</td>
<td align="center">匹配”a“或”b“或”5“或”@“</td>
</tr>
<tr>
<td align="center">[^ abc]</td>
<td align="center">匹配”a“，”b“，”c“<label style="color:red">之外</label>的任意一个字符</td>
</tr>
<tr>
<td align="center">[f-k]</td>
<td align="center">匹配”f”~”k”之间任意一个字母</td>
</tr>
<tr>
<td align="center">[^ A-F0-3]</td>
<td align="center">匹配”A”~“F” , “0”~“3”之外的任意一个字符</td>
</tr>
</tbody></table>
<p><em>正则表达式的特殊符号，被包含到中括号中，则失去了特殊意义，除了 ^,- 之外。</em></p>
<p><em>标准字符集合，除小数点外，如果被包含于中括号，自定义字符集合将包含该集合。比如：</em></p>
<p><strong>[\d.\-+]将匹配：数字、小数点、+、-</strong></p>
<h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><ul>
<li>修饰匹配次数的特殊符号</li>
</ul>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">{n}</td>
<td align="center">表达式重复n次</td>
</tr>
<tr>
<td align="center">{m,n}</td>
<td align="center">表达式至少重复m次，最多重复n次</td>
</tr>
<tr>
<td align="center">{m,}</td>
<td align="center">表达式至少重复m次</td>
</tr>
<tr>
<td align="center">?</td>
<td align="center">匹配表达式0次或者1次，相当于{0，1}</td>
</tr>
<tr>
<td align="center">+</td>
<td align="center">表达式至少出现1次，相当于{1，}</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">表达式不出现或出现任意次，相当于{0，}</td>
</tr>
</tbody></table>
<ul>
<li>匹配次数中的<strong>贪婪模式（匹配字符越多越好，默认！）</strong></li>
<li>匹配次数中的<strong>非贪婪模式（匹配字符越少越好，修饰匹配次数的特殊符号好后再加上一个”？“号）</strong></li>
</ul>
<h3 id="字符边界"><a href="#字符边界" class="headerlink" title="字符边界"></a>字符边界</h3><ul>
<li>（本组标记匹配的不是字符而是<strong>位置</strong>，符合条件的位置）</li>
</ul>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">^</td>
<td align="center">在字符串开始的地方匹配</td>
</tr>
<tr>
<td align="center">$</td>
<td align="center">在字符串结束的地方匹配</td>
</tr>
<tr>
<td align="center">\b</td>
<td align="center">匹配一个单词边界</td>
</tr>
</tbody></table>
<ul>
<li>\b匹配这样一个位置：前面的字符和后面的字符不全是\w</li>
</ul>
<hr>
<h3 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h3><ul>
<li><label styel="color = red">IGNORECASE 忽略大小写模式</label><ul>
<li>匹配时忽略大小写</li>
<li>默认情况下，正则表达式是要区分大小写的。</li>
</ul>
</li>
<li><label styel="color = red">SINGLEINE 单行模式</label><ul>
<li>整个文本看作一个字符串，只有一个开头，一个结尾。</li>
<li>使小数点”.”可以匹配包括换行符（\n）在内的任意字符。</li>
</ul>
</li>
<li><label styel="color = red">MULTILINE 多行模式</label><ul>
<li>每一行都是一个字符串，都有开头和结尾。</li>
<li>在指定了MULTILINE 之后，如果需要仅匹配字符串开始和结束位置，可以使用\A和\Z。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="选择符和分组"><a href="#选择符和分组" class="headerlink" title="选择符和分组"></a>选择符和分组</h3><table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">|  分支结构</td>
<td align="left">左右两边表达式之间”或“关系，匹配左边或右边</td>
</tr>
<tr>
<td align="center">（）捕获组</td>
<td align="left">（1），在被修饰匹配次数的时候，括号中的表示式可以作为修饰                                （2），取匹配结果的时候，括号中的表达式匹配到的内容可以单独被得到                               （3），每一对括号会分配一个编号，使用（）的捕获根据左括号的顺序从1开始自动编号。</td>
</tr>
<tr>
<td align="center">（？：Expression）非捕获组</td>
<td align="left">一些表达式中，不得不使用（），但又不需要保存（）中子表达式匹配的内容，这时可以用非捕获组来抵消使用（）带来的副作用。</td>
</tr>
</tbody></table>
<ul>
<li><strong>反向引用（\nnn）</strong><ul>
<li>每一对（）会分配一个编号，使用（）的捕获<strong>根据左括号的顺序从1开始自动编号</strong>；</li>
<li>通过反向引用，可以对<strong>分组已捕获的字符串</strong>进行应用；</li>
</ul>
</li>
</ul>
<h3 id="预搜索（零宽断言）"><a href="#预搜索（零宽断言）" class="headerlink" title="预搜索（零宽断言）"></a>预搜索（零宽断言）</h3><ul>
<li>只进行子表达式的匹配，匹配内容不计入最终匹配结果，是零宽度</li>
<li>这个位置应该符合某个条件。判断当前位置的前后字符，是否符合指定的条件，但不匹配前后的字符。<strong>是对位置的匹配。</strong></li>
<li>正则表达式匹配过程中，如果子表达式匹配到的内容是字符内容，而非位置，并被保存到最终的匹配结果中，那么就认为这个表达式是占有字符的；如果子表达式匹配的仅仅是位置，或者匹配的内容并不保存到最终的匹配结果中，那么就认为这个表达式是<label styel="color = red">零宽度</label>的。占有字符还是零宽度，是针对匹配的内容是否保存到最终的匹配结果中而言的。</li>
</ul>
<table>
<thead>
<tr>
<th>表达式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>(？=exp)</td>
<td>断言自身出现位置的后面能匹配表达式exp</td>
</tr>
<tr>
<td>(？&lt;=exp)</td>
<td>断言自身出现位置的前面能匹配表达式exp</td>
</tr>
<tr>
<td>(?!exp)</td>
<td>断言此位置的后面不能匹配表达式exp</td>
</tr>
<tr>
<td>(?&lt;!exp)</td>
<td>断言此位置的前面不能匹配表达式exp</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>说一说我在安装hexo过程中踩到的坑</title>
    <url>/2020/04/20/%E8%AF%B4%E4%B8%80%E8%AF%B4%E6%88%91%E5%9C%A8%E5%AE%89%E8%A3%85hexo%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B8%A9%E5%88%B0%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<p>第一次部署hexo，可以说把所有能踩的坑踩个遍，下面说说：</p>
<h2 id="安装node和git"><a href="#安装node和git" class="headerlink" title="安装node和git"></a>安装node和git</h2><p>这俩不必细说，一路向下就OK了</p>
<p>便说一下，windows在git安装完后，就可以直接使用git bash来敲命令行了，不用自带的cmd，cmd有点难用而且找不到hexo。</p>
<p>而git的使用方法，右键 –》Git Bash Here。</p>
<a id="more"></a>

<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>安装淘宝镜像cnpm</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">npm</span> install -g cnpm --registry=https://registry.<span class="built_in">npm</span>.taobao.org</span><br></pre></td></tr></table></figure>

<p>安装hexo</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure>

<p>安装hexo之后</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo -v</span></span><br></pre></td></tr></table></figure>

<p>查看是否安装成功，如果不成功的话，别着急配置，一下环境变量，在系统变量path下添加路径即可正常使用hexo。</p>
<blockquote>
<p>C:\MYBLOG\NodeJs\node_global\node_modules\hexo-cli\bin</p>
</blockquote>
<p>这是我的变量路径，大家参考一下。</p>
<p>另外这里也狠狠的坑了我一把，因为之前看到有教程说可以不用git，所以我一直都用自己的cmd，然而，到这一步时发现</p>
<blockquote>
<p>‘hexo’ 不是内部或外部命令，也不是可运行的程序<br>或批处理文件。</p>
</blockquote>
<p>直到我打开了git，，，</p>
<p>所以在这之后一定要用git</p>
<h2 id="创建及运行博客"><a href="#创建及运行博客" class="headerlink" title="创建及运行博客"></a>创建及运行博客</h2><p>新建一个空文件夹，<strong>作为博客根目录，在该根目录下，初始化博客</strong> ，这里要注意，这个文件夹很重要。</p>
<p>在该根目录下，右键进入git</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">hexo</span> <span class="string">init</span></span><br><span class="line"><span class="attr">cnpm</span> <span class="string">install</span></span><br><span class="line"><span class="attr">hexo</span> <span class="string">g</span></span><br><span class="line"><span class="attr">hexo</span> <span class="string">s</span></span><br></pre></td></tr></table></figure>

<p>编译博客系统：<strong>hexo g</strong></p>
<p>启动本地服务器进行预览：<strong>hexo s</strong></p>
<p>如果hexo正常工作了，输入<strong><a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></strong>就能看到博客的初始模样</p>
<p>另外常用的hexo命令有：</p>
<p>部署：<strong>hexo d</strong></p>
<p>清除缓存：<strong>hexo clean</strong></p>
<p>升级hexo：<strong>npm update hexo -g</strong></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>哈哈哈嗝哈</title>
    <url>/2020/04/20/%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<blockquote>
<p>英语四六级考试，我跟宿管大爷打招呼，宿管大爷很开心祝我考100分</p>
</blockquote>
<blockquote>
<p>孩子问妈妈：“为什么蜡烛火苗一窜一窜的” 妈妈说：“因为这是精神小火 ” </p>
</blockquote>
<blockquote>
<p>“丢死人了!”王老汉-一边喊着一边把尸体扔下了楼。</p>
</blockquote>
<blockquote>
<p>王老汉愤怒地打开水龙头，因为开水龙头烫着他了。</p>
</blockquote>
<blockquote>
<p>出门打架如果派出所有人，那就不需要派出所有人。</p>
</blockquote>
<a id="more"></a>

<p><img src="/2020/04/20/%E9%9A%8F%E7%AC%94/yao.jpg" alt="..."></p>
<blockquote>
<p>一群伟大的科学家死后在天堂里玩藏猫猫，轮到爱因斯坦抓人，他数到100睁开眼睛，看到所有人都藏起来了，只有牛顿还站在那里。</p>
<p>爱因斯坦走过去说：“牛顿，我抓住你了。”</p>
<p>牛顿：“不，你没有抓到牛顿。”</p>
<p>爱因斯坦：“你不是牛顿你是谁？”</p>
<p>牛顿：“你看我脚下是什么？”</p>
<p>爱因斯坦低头看到牛顿站在一块长宽都是一米的正方形的地板砖上，不解。</p>
<p>牛顿：“我脚下这是一平方米的方块，我站在上面就是牛顿/平方米，所以你抓住的不是牛顿，你抓住的是帕斯卡。”</p>
</blockquote>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程</title>
    <url>/2020/05/12/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="1、UDP编程"><a href="#1、UDP编程" class="headerlink" title="1、UDP编程"></a>1、UDP编程</h2><br>

<h3 id="1-1、UdpClient"><a href="#1-1、UdpClient" class="headerlink" title="1.1、UdpClient:"></a>1.1、UdpClient:</h3><a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> UDP编程;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 发送端</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1、使用DatagramSocket 指定端口 创建发送端端</span></span><br><span class="line"><span class="comment"> * 2、准备数据 一定转成字节数组</span></span><br><span class="line"><span class="comment"> * 3、封装成DatagramPacket包裹 ，需要制定目的地</span></span><br><span class="line"><span class="comment"> * 4、发送包裹send（DatagramPacket p）</span></span><br><span class="line"><span class="comment"> * 5、释放资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UdpClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"发送方启动中。。。"</span>);</span><br><span class="line">		<span class="comment">// 1、使用DatagramSocket 指定端口 创建发送端端</span></span><br><span class="line">		DatagramSocket client = <span class="keyword">new</span> DatagramSocket(<span class="number">8888</span>);</span><br><span class="line">		<span class="comment">// 2、准备数据 一定转成字节数组</span></span><br><span class="line">		String data = <span class="string">"老刘很嚣张"</span>;</span><br><span class="line">		<span class="keyword">byte</span>[] datas = data.getBytes();</span><br><span class="line">		<span class="comment">// 3、封装成DatagramPacket包裹 ，需要制定目的地</span></span><br><span class="line">		DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(datas, <span class="number">0</span>, datas.length, <span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">9999</span>));</span><br><span class="line">		<span class="comment">// 4、发送包裹send（DatagramPacket p）</span></span><br><span class="line">		client.send(packet);</span><br><span class="line">		<span class="comment">// 5、释放资源</span></span><br><span class="line">		client.close();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2、UdpServer"><a href="#1-2、UdpServer" class="headerlink" title="1.2、UdpServer"></a>1.2、UdpServer</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> UDP编程;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 接收端</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1、使用DatagramSocket 指定端口 创建接收端</span></span><br><span class="line"><span class="comment"> * 2、准备容器 封装成DatagramPacket包裹</span></span><br><span class="line"><span class="comment"> * 3、阻塞式接受包裹receive（DatagramPacket p）</span></span><br><span class="line"><span class="comment"> * 4、分析数据</span></span><br><span class="line"><span class="comment"> * 	 byte[] getData()</span></span><br><span class="line"><span class="comment"> * 			getLength()</span></span><br><span class="line"><span class="comment"> * 5、释放资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UdpServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"接收方启动中。。。"</span>);</span><br><span class="line">		<span class="comment">//1、使用DatagramSocket 指定端口 创建接收端</span></span><br><span class="line">		DatagramSocket server = <span class="keyword">new</span> DatagramSocket(<span class="number">9999</span>); </span><br><span class="line">		<span class="comment">//2、准备容器 封装成DatagramPacket包裹</span></span><br><span class="line">		<span class="keyword">byte</span>[] container = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">64</span>];</span><br><span class="line">		DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(container,<span class="number">0</span>,container.length);</span><br><span class="line">		<span class="comment">//3、阻塞式接受包裹receive（DatagramPacket p）</span></span><br><span class="line">		server.receive(packet); <span class="comment">//阻塞式，会有延迟</span></span><br><span class="line">		<span class="comment">//4、分析数据</span></span><br><span class="line">		<span class="comment">//	 byte[] getData()</span></span><br><span class="line">		<span class="comment">// 			getLength()</span></span><br><span class="line">		<span class="keyword">byte</span>[] datas = packet.getData();</span><br><span class="line">		<span class="keyword">int</span> len = packet.getLength();</span><br><span class="line">		System.out.println(<span class="keyword">new</span> String(datas,<span class="number">0</span>,len));</span><br><span class="line">		<span class="comment">//5、释放资源</span></span><br><span class="line">		server.close();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br><br></p>
<h2 id="2、TCP编程"><a href="#2、TCP编程" class="headerlink" title="2、TCP编程"></a>2、TCP编程</h2><br>

<h3 id="2-1、TcpClient"><a href="#2-1、TcpClient" class="headerlink" title="2.1、TcpClient"></a>2.1、TcpClient</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> TCP编程;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -TCp通信的客户端：向服务器发送连接请求，给服务器发送数据，读取服务器回写的数据。</span></span><br><span class="line"><span class="comment"> * -表示客户端的类：</span></span><br><span class="line"><span class="comment"> * ----java.net.Socket：此类实现客户端套接字（也可以就叫“套接字”）。套接字是两台计算机间通信的端点。</span></span><br><span class="line"><span class="comment"> * ----套接字：包含了IP地址和端口号的网络单位。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * -构造方法：</span></span><br><span class="line"><span class="comment"> * ----Socket(String host, int port) 创建一个流套接字并将其连接到指定主机上的指定端口号。</span></span><br><span class="line"><span class="comment"> * ----参数：</span></span><br><span class="line"><span class="comment"> * -------String host:服务器主机的名称/服务器的ip地址。</span></span><br><span class="line"><span class="comment"> * -------int port：服务器的端口号。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * -成员方法：</span></span><br><span class="line"><span class="comment"> * ----OutputStream getOutputStream() 返回此套接字的输出流。</span></span><br><span class="line"><span class="comment"> * ----InputStream getInputStream() 返回此套接字的输入流。</span></span><br><span class="line"><span class="comment"> * ----close()关闭此套接字。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * -实现步骤：</span></span><br><span class="line"><span class="comment"> * ----1、创建一个客户端对象Socket，构造方法绑定服务器的IP地址和端口号。</span></span><br><span class="line"><span class="comment"> * ----2、使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象。</span></span><br><span class="line"><span class="comment"> * ----3、使用网络字节输出流OutputStream对象中的方法write，给服务器发送数据。</span></span><br><span class="line"><span class="comment"> * ----4、使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象。</span></span><br><span class="line"><span class="comment"> * ----5、使用网络字节输入流InputStream对象中的方法read，读取服务器回写的数据。</span></span><br><span class="line"><span class="comment"> * ----6、释放资源（Socket)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * -注意事项：</span></span><br><span class="line"><span class="comment"> * ----1、客户端和服务器端进行交互，必须使用Socket中提供的网络流，不能使用自己创建的流对象。</span></span><br><span class="line"><span class="comment"> * ----2、当我们创建客户端对象Socket的时候，就会去请求服务器和服务器经过三次握手建立连接通路</span></span><br><span class="line"><span class="comment"> * 		---如果这时服务器没有启动，那么就会抛出异常</span></span><br><span class="line"><span class="comment"> * 		---如果这时服务器已经启动，那么就可以进行交互了	</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//1、创建一个客户端对象Socket，构造方法绑定服务器的IP地址和端口号。</span></span><br><span class="line">		Socket socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">8888</span>);</span><br><span class="line">		<span class="comment">//2、使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象。</span></span><br><span class="line">		OutputStream os = socket.getOutputStream(); </span><br><span class="line">		<span class="comment">//3、使用网络字节输出流OutputStream对象中的方法write，给服务器发送数据。</span></span><br><span class="line">		os.write(<span class="string">"客户端：天下风云出我辈，一入江湖岁月催"</span>.getBytes());</span><br><span class="line">		<span class="comment">//4、使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象。</span></span><br><span class="line">		InputStream is = socket.getInputStream(); </span><br><span class="line">		<span class="comment">//5、使用网络字节输入流InputStream对象中的方法read，读取服务器回写的数据。</span></span><br><span class="line">		<span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">int</span> len = is.read(bytes);</span><br><span class="line">		System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">		<span class="comment">//6、释放资源（Socket)</span></span><br><span class="line">		socket.close();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2、TcpServer"><a href="#2-2、TcpServer" class="headerlink" title="2.2、TcpServer"></a>2.2、TcpServer</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> TCP编程;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -TCp通信的服务器端：接收客户端的请求，读取客户端发送的数据，给客户端回写数据。</span></span><br><span class="line"><span class="comment"> * -表示服务器的类：</span></span><br><span class="line"><span class="comment"> * ----java.net.ServerSocket：这个类实现了服务器套接字。</span></span><br><span class="line"><span class="comment"> * ----套接字：包含了IP地址和端口号的网络单位。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * -构造方法：</span></span><br><span class="line"><span class="comment"> * ----ServerSocket(int port) 创建一个服务器套接字，绑定到指定的端口。 </span></span><br><span class="line"><span class="comment"> * ----参数：</span></span><br><span class="line"><span class="comment"> * -------int port：端口号。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * -服务器端必须明确一件事情，必须的知道是哪一个客户端请求的服务器  所以可以使用accept方法获取到请求的客户端对象Socket。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * -成员方法：</span></span><br><span class="line"><span class="comment"> * ----Socket accept() 监听要对这个套接字作出的连接并接受它。 </span></span><br><span class="line"><span class="comment"> * ----close()关闭此套接字。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * -实现步骤：</span></span><br><span class="line"><span class="comment"> * ----1、创建一个服务器端ServerSocket对象和系统要指定的端口号。</span></span><br><span class="line"><span class="comment"> * ----2、使用ServerSocket对象中的方法accept获取到请求客户端的Socket对象。</span></span><br><span class="line"><span class="comment"> * ----3、使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象。</span></span><br><span class="line"><span class="comment"> * ----4、使用网络字节输入流InputStream对象中的方法read，读取客户端发送的数据。</span></span><br><span class="line"><span class="comment"> * ----5、使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象。</span></span><br><span class="line"><span class="comment"> * ----6、使用网络字节输出流OutputStream对象中的方法write，给客户端回写数据。</span></span><br><span class="line"><span class="comment"> * ----7、释放资源（Socket，ServerSocket)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//1、创建一个服务器端ServerSocket对象和系统要指定的端口号。</span></span><br><span class="line">		ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>); </span><br><span class="line">		<span class="comment">//2、使用ServerSocket对象中的方法accept获取到请求客户端的Socket对象。</span></span><br><span class="line">		Socket socket = server.accept(); </span><br><span class="line">		<span class="comment">//3、使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象。</span></span><br><span class="line">		InputStream is = socket.getInputStream(); </span><br><span class="line">		<span class="comment">//4、使用网络字节输入流InputStream对象中的方法read，读取客户端发送的数据。</span></span><br><span class="line">		<span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">int</span> len = is.read(bytes);</span><br><span class="line">		System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">		<span class="comment">//5、使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象。</span></span><br><span class="line">		OutputStream os = socket.getOutputStream();</span><br><span class="line">		<span class="comment">//6、使用网络字节输出流OutputStream对象中的方法write，给客户端回写数据。</span></span><br><span class="line">		os.write(<span class="string">"服务器：皇图霸业谈笑中，不胜人生一场醉"</span>.getBytes());</span><br><span class="line">		<span class="comment">//7、释放资源（Socket，ServerSocket)</span></span><br><span class="line">		socket.close();</span><br><span class="line">		server.close();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
</search>
